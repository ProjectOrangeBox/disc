<?php

declare(strict_types=1);

namespace dmyers\disc;

use dmyers\disc\File;
use dmyers\disc\Directory;
use dmyers\disc\exceptions\DiscException;

/**
 * File System Functions
 *
 * File System Abstraction which automatically
 * works in a given root path
 *
 * Can be added with composer by adding a composer.json file with:
 *
 *"autoload": {
 *   "files": ["src/Disc.php"]
 * }
 */
class Disc
{
	protected static $rootPath = '';
	protected static $rootLength = 0;
	protected static $autoGenerateDirectories = true;

	/**
	 * set application root directory
	 *
	 * @param string $path [path to root directory]
	 * @return void
	 */
	public static function root(string $path, bool $chdir = true): void
	{
		/* Returns canonicalized absolute pathname */
		$realpath = \realpath($path);

		if (!$realpath) {
			throw new discException('"' . $path . '" is not a valid directory.');
		}

		/* save it */
		self::$rootPath = $realpath;

		/* calculate it once here */
		self::$rootLength = \strlen($realpath);

		/* change directory to it */
		if ($chdir) {
			\chdir(self::$rootPath);
		}

		/* default true they can change it to false if they need to with the autoGenerateDirectories function */
		self::autoGenerateDirectories(true);
	}

	public static function getRoot(): string
	{
		return self::$rootPath;
	}

	public static function autoGenerateDirectories(bool $bool = true): void
	{
		self::$autoGenerateDirectories = $bool;
	}

	/**
	 * Format a given path so it's based on the applications root folder __ROOT__.
	 *
	 * Either add or remove __ROOT__ from path
	 *
	 * @param string $path [path to file/directory]
	 * @param bool $remove false [remove the root path]
	 *
	 * @return string
	 */
	public static function resolve(string $path, bool $remove = false, string $required = ''): string
	{
		if (empty(self::$rootPath)) {
			throw new discException(__METHOD__ . ' root path is not defined. Use disc::root(...).');
		}

		/* strip it if root path is already present */
		$path = (\substr($path, 0, self::$rootLength) == self::$rootPath) ? \substr($path, self::$rootLength) : $path;

		$short = DIRECTORY_SEPARATOR . \trim($path, DIRECTORY_SEPARATOR);
		$long = self::$rootPath . $short;

		switch ($required) {
			case 'file':
				if (!file_exists($long) && !is_file($long)) {
					throw new discException('No such file. ' . $short);
				}
				break;
			case 'directory':
				if (!file_exists($long) && !is_dir($long)) {
					throw new discException('No such directory. ' . $short);
				}
				break;
			default:
		}

		/* now resolve - stripped or added? */
		return ($remove) ? $short : $long;
	}

	public static function stripRootPath(string $files, bool $remove = true)
	{
		return self::resolve($files, $remove);
	}

	public static function stripRootPaths(array $files, bool $remove = true)
	{
		foreach ($files as $index => $file) {
			$files[$index] = self::resolve($file, $remove);
		}

		return $files;
	}


	public static function autoGenMissingDirectory(string $filePath): bool
	{
		return (self::$autoGenerateDirectories) ? (new Directory(dirname(self::resolve($filePath))))->create() : true;
	}

	public static function exists(string $path): bool
	{
		return \file_exists(self::resolve($path));
	}

	public static function require(string $requiredPath) /* mixed|bool */
	{
		return require self::resolve($requiredPath, false, 'file');
	}

	public static function requireOnce(string $requiredPath) /* mixed|bool */
	{
		return require_once self::resolve($requiredPath, false, 'file');
	}

	public static function include(string $requiredPath) /* mixed|bool */
	{
		return include self::resolve($requiredPath, false, 'file');
	}

	public static function includeOnce(string $requiredPath) /* mixed|bool */
	{
		return include_once self::resolve($requiredPath, false, 'file');
	}

	/* generators */

	public static function directory(string $path): Directory
	{
		$path = self::resolve($path);

		if (is_file($path)) {
			throw new discException(self::resolve($path, true) . ' is a File.');
		}

		return new Directory($path);
	}

	public static function file(string $path): File
	{
		$path = self::resolve($path);

		if (is_dir($path)) {
			throw new discException(self::resolve($path, true) . ' is a Directory.');
		}

		return new File($path);
	}

	/* formatters */

	public static function formatSize(int $bytes): string
	{
		$i = floor(log($bytes, 1024));

		return round($bytes / pow(1024, $i), [0, 1, 2, 2, 3][$i]) . ['B', 'kB', 'MB', 'GB', 'TB'][$i];
	}

	/**
	 * Method formatTime
	 *
	 * @param $timestamp [explicite description]
	 * @param string $dateFormat [explicite description]
	 *
	 * @return void
	 */
	public static function formatTime(?int $timestamp, ?string $dateFormat = null) /* int|string */
	{
		return ($timestamp !== null && $dateFormat !== null) ? date($dateFormat, $timestamp) : $timestamp;
	}

	public static function formatPermissions(int $mode, int $option = 3): string
	{
		$info = '';

		if (1 & $option) {
			switch ($mode & 0xF000) {
					// socket
				case 0xC000:
					$info = 's';
					break;
					// symbolic link
				case 0xA000:
					$info = 'l';
					break;
					// regular
				case 0x8000:
					$info = 'r';
					break;
					// block special
				case 0x6000:
					$info = 'b';
					break;
					// directory
				case 0x4000:
					$info = 'd';
					break;
					// character special
				case 0x2000:
					$info = 'c';
					break;
					// FIFO pipe
				case 0x1000:
					$info = 'p';
					break;
					// unknown
				default:
					$info = 'u';
			}
		}

		if (2 & $option) {
			// Owner
			$info .= (($mode & 0x0100) ? 'r' : '-');
			$info .= (($mode & 0x0080) ? 'w' : '-');
			$info .= (($mode & 0x0040) ? (($mode & 0x0800) ? 's' : 'x') : (($mode & 0x0800) ? 'S' : '-'));

			// Group
			$info .= (($mode & 0x0020) ? 'r' : '-');
			$info .= (($mode & 0x0010) ? 'w' : '-');
			$info .= (($mode & 0x0008) ? (($mode & 0x0400) ? 's' : 'x') : (($mode & 0x0400) ? 'S' : '-'));

			// World
			$info .= (($mode & 0x0004) ? 'r' : '-');
			$info .= (($mode & 0x0002) ? 'w' : '-');
			$info .= (($mode & 0x0001) ? (($mode & 0x0200) ? 't' : 'x') : (($mode & 0x0200) ? 'T' : '-'));
		}

		return $info;
	}
} /* end class */
